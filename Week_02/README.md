### Hash表、映射、集合

哈希表，也叫散列表，是根据关键键码值而进行访问的数据结构，
它通过把关键码值映射到表的一个位置来访问记录，以加快查询速度
这个映射函数叫散列函数，存放记录的数组叫散列表
工程实现：LRU cache 键值对存放Redis 
哈希表的实现：
Key => 哈希函数=>存放的位置 
如果有多个值哈希函数解析出的结果相同，称之为哈希碰撞，解决办法：拉出一个链表，依次存放(如果很长，效率会退化，查询的效率会变成On )
但哈希函数设计的好的话，碰撞的概率很小，所以平均的话， 可以认为哈希函数的查询是O1 

哈希函数设计好的时候大部分情况下：查询、删除、添加都是O1，但不好的情况下，比如碰撞多了会拉出链表，会变为都是On

哈希表抽象出来了 map 和set
map: key 不能重复
Set:  不重复元素 的集合

题解：异位词，利用chartCodeAt - 97 解题

tree Map 和 tree set 复杂度都是Ologn

### 树、二叉树、二叉搜索树
linkLIst是特殊化的tree，树就是有两个以上指针的linklist
Tree是特殊化的图， 树就是没有环的图
[js树的实现](https:/www.cnblogs.com/jaxu/p/11309385.html)

二叉树的遍历(递归，因为树的结构写循环不好写，递归调用相对简单 )
- 1、前序： 根=>左=>右
- 2、中序:   左=>根=>右
- 3、后序:   左=>右=>根

二叉搜索树 
查找普通的树，必须把整个树遍历一遍 On 和链表感觉就没有太大的区别，这样显得没有了意义（毕竟升维，应当降低时间复杂度）
所以一般要 把树变得有序，这样查找更有效 

定义： 二叉搜索树，也称二叉排序树、有序二叉树、排序二叉树，是指一颗空树或者具有以下性质的二叉树
- 1、左子树所有节点的值均小于它根节点的值
- 2、右子树所有节点的值均大于它根节点的值
- 3、以此类推：左右子树也分别为二叉查找树。（这就是重复性）
中序遍历：生序排列

二叉搜索树的常见操作：
- 1、查询
- 2、插入新节点（创建）
- 3、删除 (如果没有子节点就直接删除，如果有则找离他最近比他大的代替（右子树的第一个节点 ）)
查询和操作都是Ologn，如果退化成链表，时间复杂度就是On
(二叉搜索树 Demo)[https://visualgo.net/zh/bst?slide=1]
### 堆Heap
Heap： 可以迅速找到一堆数中的最大值或者最小值的数据结构
大顶堆/大根堆： 将根节点最大的堆
小顶堆/小根堆： 将根节点最小的堆
常见的堆有二叉堆、斐波拉契堆

大顶堆：
find-max: O1
delete-max: Ologn
insert: Ologn 或 O1

#### 二叉堆
有完全二叉树实现
特征：
1、是一个完全树
2、树的任意节点值都>=它子节点的值